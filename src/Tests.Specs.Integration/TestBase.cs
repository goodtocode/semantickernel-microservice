using FluentAssertions.Execution;
using Goodtocode.SemanticKernel.Core.Application.Abstractions;
using Goodtocode.SemanticKernel.Core.Application.Common.Exceptions;
using Goodtocode.SemanticKernel.Core.Application.Common.Mappings;
using Goodtocode.SemanticKernel.Infrastructure.SemanticKernel.Options;
using Goodtocode.SemanticKernel.Infrastructure.SemanticKernel.Plugins;
using Goodtocode.SemanticKernel.Infrastructure.SqlServer.Persistence;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using System.Reflection;

namespace Goodtocode.SemanticKernel.Specs.Integration;

public abstract class TestBase : IDisposable
{
    public enum CommandResponseType
    {
        Successful,
        BadRequest,
        NotFound,
        Error
    }

    internal string def = string.Empty;
    internal IDictionary<string, string[]> commandErrors = new ConcurrentDictionary<string, string[]>();
    internal Exception? exception;
    internal CommandResponseType responseType;
    internal ValidationResult validationResponse = new();
    internal SemanticKernelContext context;
    internal IConfiguration configuration;
    internal Kernel kernel = new();
    internal OpenAIOptions optionsOpenAi = new();

    public TestBase()
    {
        Mapper = new MapperConfiguration(cfg => { cfg.AddProfile<MappingProfile>(); })
            .CreateMapper();

        context = new SemanticKernelContext(new DbContextOptionsBuilder<SemanticKernelContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString()).Options);

        var executingType = Assembly.GetExecutingAssembly().GetTypes()
            .FirstOrDefault(x => x.Name == "AutoGeneratedProgram") ?? typeof(TestBase);
        configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.test.json", optional: true, reloadOnChange: true)
            .AddUserSecrets(executingType.Assembly, optional: true)
            .AddEnvironmentVariables()
            .Build();


        // The SK Plugins currently rely on GetRequiredService<ISemanticKernelContext>(), so we need to register it as a scoped service.
        // This is a workaround to allow the plugins to be registered in the DI container as Singleton which SK memory wants, despite an EF dependency which wants Scoped.
        var services = new ServiceCollection();
        services.AddDbContext<SemanticKernelContext>(options => options.UseInMemoryDatabase(Guid.NewGuid().ToString()));
        services.AddScoped<ISemanticKernelContext, SemanticKernelContext>();        
        var provider = services.BuildServiceProvider();

        configuration.GetSection(nameof(OpenAI)).Bind(optionsOpenAi);
        var builder = Kernel.CreateBuilder();
#pragma warning disable SKEXP0010 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        builder.Services
            .AddOpenAIChatCompletion(modelId: optionsOpenAi.ChatCompletionModelId, apiKey: optionsOpenAi.ApiKey)
            .AddOpenAIAudioToText(modelId: optionsOpenAi.AudioModelId, apiKey: optionsOpenAi.ApiKey)
            .AddOpenAITextToAudio(modelId: optionsOpenAi.AudioModelId, apiKey: optionsOpenAi.ApiKey)
            .AddOpenAITextToImage(modelId: optionsOpenAi.ImageModelId, apiKey: optionsOpenAi.ApiKey);
#pragma warning restore SKEXP0010
        builder.Services.AddLogging(logging =>
        {
            logging.SetMinimumLevel(LogLevel.Debug);
        });
        kernel = builder.Build();

        var serviceProvider = builder.Services.BuildServiceProvider();
        var authorsPlugin = new AuthorsPlugin(serviceProvider);
        var chatSessionsPlugin = new ChatSessionsPlugin(serviceProvider);
        var chatMessagesPlugin = new ChatMessagesPlugin(serviceProvider);

        kernel.ImportPluginFromObject(authorsPlugin, nameof(AuthorsPlugin));
        kernel.ImportPluginFromObject(chatSessionsPlugin, nameof(ChatSessionsPlugin));
        kernel.ImportPluginFromObject(chatMessagesPlugin, nameof(ChatMessagesPlugin));
    }

    internal IMapper Mapper { get; }

    internal CommandResponseType HandleAssignResponseType
        (Exception e)
    {
        exception = e;
        switch (e)
        {
            case CustomValidationException validationException:
                commandErrors = validationException.Errors;
                responseType = CommandResponseType.BadRequest;
                break;
            case CustomNotFoundException:
                responseType = CommandResponseType.NotFound;
                break;
            default:
                responseType = CommandResponseType.Error;
                break;
        }

        return responseType;
    }

    internal void HandleHasResponseType(string response)
    {
        switch (response)
        {
            case "Success":
                using (new AssertionScope())
                {
                    responseType.Should().Be(CommandResponseType.Successful);
                    exception?.Should().BeNull("An exception was thrown: {0}. Inner exception: {1}", exception.Message, exception.InnerException?.Message);
                }
                break;
            case "BadRequest":
                responseType.Should().Be(CommandResponseType.BadRequest);
                break;
            case "NotFound":
                responseType.Should().Be(CommandResponseType.NotFound);
                break;
        }
    }

    internal void HandleExpectedValidationErrorsAssertions(string expectedErrors)
    {
        var def = this.def;

        if (string.IsNullOrWhiteSpace(expectedErrors)) return;

        var expectedErrorsCollection = expectedErrors.Split(",");

        foreach (var field in expectedErrorsCollection)
        {
            var hasCommandValidatorErrors = validationResponse.Errors.Any(x => x.PropertyName == field.Trim());
            var hasCommandErrors = commandErrors.Any(x => x.Key == field.Trim());
            var hasErrorMatch = hasCommandErrors || hasCommandValidatorErrors;
            hasErrorMatch.Should().BeTrue();
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            context?.Dispose();
        }
    }
}