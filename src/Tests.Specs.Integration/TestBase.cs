using System.Reflection;
using FluentAssertions.Execution;
using Goodtocode.SemanticKernel.Core.Application.Common.Exceptions;
using Goodtocode.SemanticKernel.Core.Application.Common.Mappings;
using Goodtocode.SemanticKernel.Infrastructure.SemanticKernel.Options;
using Goodtocode.SemanticKernel.Infrastructure.SqlServer.Persistence;
using Microsoft.Extensions.Configuration;

namespace Goodtocode.SemanticKernel.Specs.Integration;

public abstract class TestBase : IDisposable
{
    public enum CommandResponseType
    {
        Successful,
        BadRequest,
        NotFound,
        Error
    }

    internal string def = string.Empty;
    internal IDictionary<string, string[]> commandErrors = new ConcurrentDictionary<string, string[]>();
    internal Exception? exception;
    internal CommandResponseType responseType;
    internal ValidationResult validationResponse = new();
    internal SemanticKernelContext context;
    internal IConfiguration configuration;
    internal OpenAIOptions optionsOpenAi = new();

    public TestBase()
    {
        Mapper = new MapperConfiguration(cfg => { cfg.AddProfile<MappingProfile>(); })
            .CreateMapper();

        context = new SemanticKernelContext(new DbContextOptionsBuilder<SemanticKernelContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString()).Options);

        var executingType = Assembly.GetExecutingAssembly().GetTypes()
            .FirstOrDefault(x => x.Name == "AutoGeneratedProgram") ?? typeof(TestBase);
        configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.test.json", optional: true, reloadOnChange: true)
            .AddUserSecrets(executingType.Assembly, optional: true)
            .AddEnvironmentVariables()
            .Build();

        configuration.GetSection(nameof(OpenAI)).Bind(optionsOpenAi);
    }

    internal IMapper Mapper { get; }

    internal CommandResponseType HandleAssignResponseType
        (Exception e)
    {
        exception = e;
        switch (e)
        {
            case CustomValidationException validationException:
                commandErrors = validationException.Errors;
                responseType = CommandResponseType.BadRequest;
                break;
            case CustomNotFoundException:
                responseType = CommandResponseType.NotFound;
                break;
            default:
                responseType = CommandResponseType.Error;
                break;
        }

        return responseType;
    }

    internal void HandleHasResponseType(string response)
    {
        switch (response)
        {
            case "Success":
                using (new AssertionScope())
                {
                    responseType.Should().Be(CommandResponseType.Successful);
                    exception?.Should().BeNull("An exception was thrown: {0}. Inner exception: {1}", exception.Message, exception.InnerException?.Message);
                }
                break;
            case "BadRequest":
                responseType.Should().Be(CommandResponseType.BadRequest);
                break;
            case "NotFound":
                responseType.Should().Be(CommandResponseType.NotFound);
                break;
        }
    }

    internal void HandleExpectedValidationErrorsAssertions(string expectedErrors)
    {
        var def = this.def;

        if (string.IsNullOrWhiteSpace(expectedErrors)) return;

        var expectedErrorsCollection = expectedErrors.Split(",");

        foreach (var field in expectedErrorsCollection)
        {
            var hasCommandValidatorErrors = validationResponse.Errors.Any(x => x.PropertyName == field.Trim());
            var hasCommandErrors = commandErrors.Any(x => x.Key == field.Trim());
            var hasErrorMatch = hasCommandErrors || hasCommandValidatorErrors;
            hasErrorMatch.Should().BeTrue();
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            context?.Dispose();
        }
    }
}